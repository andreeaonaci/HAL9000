diff --git a/.vs/HAL9000/v16/.suo b/.vs/HAL9000/v16/.suo
index 1e8654c..e88e657 100644
Binary files a/.vs/HAL9000/v16/.suo and b/.vs/HAL9000/v16/.suo differ
diff --git a/.vs/HAL9000/v16/Browse.VC.db b/.vs/HAL9000/v16/Browse.VC.db
index 2927340..8f87e4e 100644
Binary files a/.vs/HAL9000/v16/Browse.VC.db and b/.vs/HAL9000/v16/Browse.VC.db differ
diff --git a/.vs/HAL9000/v16/Solution.VC.db b/.vs/HAL9000/v16/Solution.VC.db
index ea5c763..507156b 100644
Binary files a/.vs/HAL9000/v16/Solution.VC.db and b/.vs/HAL9000/v16/Solution.VC.db differ
diff --git a/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch b/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch
index 1ab2535..e8f1534 100644
Binary files a/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch and b/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch differ
diff --git a/.vs/HAL9000/v16/ipch/AutoPCH/3504819d756ddbe9/THREAD.ipch b/.vs/HAL9000/v16/ipch/AutoPCH/3504819d756ddbe9/THREAD.ipch
new file mode 100644
index 0000000..57f99fc
Binary files /dev/null and b/.vs/HAL9000/v16/ipch/AutoPCH/3504819d756ddbe9/THREAD.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/.suo b/.vs/HAL9000_WithoutApplications/v16/.suo
index fab7dce..f2a2371 100644
Binary files a/.vs/HAL9000_WithoutApplications/v16/.suo and b/.vs/HAL9000_WithoutApplications/v16/.suo differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db b/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db
index b19850c..86f2915 100644
Binary files a/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db and b/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db b/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db
index 9bd9e64..ddc43ee 100644
Binary files a/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db and b/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/1ef05c8314040276/MUTEX.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/1ef05c8314040276/MUTEX.ipch
new file mode 100644
index 0000000..fda57e6
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/1ef05c8314040276/MUTEX.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2357e4494828d1be/SPINLOCK.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2357e4494828d1be/SPINLOCK.ipch
new file mode 100644
index 0000000..7f485fb
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2357e4494828d1be/SPINLOCK.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2371012fc45db0e5/THREAD.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2371012fc45db0e5/THREAD.ipch
new file mode 100644
index 0000000..6754aad
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2371012fc45db0e5/THREAD.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch
index bed45ed..ab902d9 100644
Binary files a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2a818a5d2cfd32ae/ACPI_INTERFACE.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2a818a5d2cfd32ae/ACPI_INTERFACE.ipch
new file mode 100644
index 0000000..a68a59e
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2a818a5d2cfd32ae/ACPI_INTERFACE.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/4a2cad7545002cd8/IDT_HANDLERS.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/4a2cad7545002cd8/IDT_HANDLERS.ipch
new file mode 100644
index 0000000..ba415ea
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/4a2cad7545002cd8/IDT_HANDLERS.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/5177c890ace0e7cd/SMP.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/5177c890ace0e7cd/SMP.ipch
new file mode 100644
index 0000000..fa3b953
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/5177c890ace0e7cd/SMP.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/64b347674aaff517/LOG.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/64b347674aaff517/LOG.ipch
new file mode 100644
index 0000000..2a40c4f
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/64b347674aaff517/LOG.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/6b47ada2dc567d6b/ISR.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/6b47ada2dc567d6b/ISR.ipch
new file mode 100644
index 0000000..40e1732
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/6b47ada2dc567d6b/ISR.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/705c3ff52df7407f/ENTRY64.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/705c3ff52df7407f/ENTRY64.ipch
new file mode 100644
index 0000000..3f8a6ed
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/705c3ff52df7407f/ENTRY64.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/7ee9b6bb5176d52c/TEST_THREAD.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/7ee9b6bb5176d52c/TEST_THREAD.ipch
new file mode 100644
index 0000000..2f84474
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/7ee9b6bb5176d52c/TEST_THREAD.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/a186d121de9bcbbb/ASSERT.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/a186d121de9bcbbb/ASSERT.ipch
new file mode 100644
index 0000000..c7e5d47
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/a186d121de9bcbbb/ASSERT.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ac0dbac2f758ccf6/ACPI_INTERFACE.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ac0dbac2f758ccf6/ACPI_INTERFACE.ipch
new file mode 100644
index 0000000..d390c39
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ac0dbac2f758ccf6/ACPI_INTERFACE.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/b604a6d970aa58b/TEST_TIMER.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/b604a6d970aa58b/TEST_TIMER.ipch
new file mode 100644
index 0000000..828f86f
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/b604a6d970aa58b/TEST_TIMER.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ce1d13151b21ceb0/LOCK_COMMON.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ce1d13151b21ceb0/LOCK_COMMON.ipch
new file mode 100644
index 0000000..a69ade0
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ce1d13151b21ceb0/LOCK_COMMON.ipch differ
diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/f7d7cc9ccc14f827/EX_EVENT.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/f7d7cc9ccc14f827/EX_EVENT.ipch
new file mode 100644
index 0000000..d148732
Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/f7d7cc9ccc14f827/EX_EVENT.ipch differ
diff --git a/HAL9000/headers/thread_internal.h b/HAL9000/headers/thread_internal.h
index 789fe68..a80e747 100644
--- a/HAL9000/headers/thread_internal.h
+++ b/HAL9000/headers/thread_internal.h
@@ -40,6 +40,10 @@ typedef struct _THREAD
     TID                     Id;
     char*                   Name;
 
+    //bagat de la mine
+    QWORD lastScheduledTime;
+    THREAD_PRIORITY OriginalPriority;
+
     // Currently the thread priority is not used for anything
     THREAD_PRIORITY         Priority;
     THREAD_STATE            State;
@@ -90,6 +94,8 @@ typedef struct _THREAD
     PVOID                   UserStack;
 
     struct _PROCESS*        Process;
+
+    TID parentTid;
 } THREAD, *PTHREAD;
 
 //******************************************************************************
diff --git a/HAL9000/src/ex_event.c b/HAL9000/src/ex_event.c
index 8c58e20..a73450a 100644
--- a/HAL9000/src/ex_event.c
+++ b/HAL9000/src/ex_event.c
@@ -1,6 +1,7 @@
 #include "HAL9000.h"
 #include "ex_event.h"
 #include "thread_internal.h"
+#include "thread.h"
 
 #include "cpumu.h"
 
@@ -80,6 +81,8 @@ ExEventWaitForSignal(
     INOUT   EX_EVENT*      Event
     )
 {
+    LOG("ExEventWaitForSignal started");
+    //__halt();
     PTHREAD pCurrentThread;
     INTR_STATE dummyState;
     INTR_STATE oldState;
@@ -97,7 +100,8 @@ ExEventWaitForSignal(
     while (TRUE != _InterlockedCompareExchange8(&Event->Signaled, newState, TRUE))
     {
         LockAcquire(&Event->EventLock, &dummyState);
-        InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
+        //InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
+        InsertOrderedList(&Event->WaitingList, &pCurrentThread->ReadyList, ThreadSchedulerCompareFunction, NULL);
         ThreadTakeBlockLock();
         LockRelease(&Event->EventLock, dummyState);
         ThreadBlock();
@@ -110,6 +114,8 @@ ExEventWaitForSignal(
             break;
         }
     }
-
+    LOG("ExEventWaitForSignal finished");
+    //__halt();
     CpuIntrSetState(oldState);
+    //LOG("ExEventWaitForSignal finished");
 }
\ No newline at end of file
diff --git a/HAL9000/src/mutex.c b/HAL9000/src/mutex.c
index 9c82227..3a129fe 100644
--- a/HAL9000/src/mutex.c
+++ b/HAL9000/src/mutex.c
@@ -21,24 +21,25 @@ MutexInit(
 
     Mutex->MaxRecursivityDepth = Recursive ? MUTEX_MAX_RECURSIVITY_DEPTH : 1;
 }
-
 ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Mutex)
 REQUIRES_NOT_HELD_LOCK(*Mutex)
 void
 MutexAcquire(
     INOUT       PMUTEX      Mutex
-    )
+)
 {
+    LOG("MutexAcquire started");
+    //__halt();
     INTR_STATE dummyState;
     INTR_STATE oldState;
     PTHREAD pCurrentThread = GetCurrentThread();
 
-    ASSERT( NULL != Mutex);
-    ASSERT( NULL != pCurrentThread );
+    ASSERT(NULL != Mutex);
+    ASSERT(NULL != pCurrentThread);
 
     if (pCurrentThread == Mutex->Holder)
     {
-        ASSERT( Mutex->CurrentRecursivityDepth < Mutex->MaxRecursivityDepth );
+        ASSERT(Mutex->CurrentRecursivityDepth < Mutex->MaxRecursivityDepth);
 
         Mutex->CurrentRecursivityDepth++;
         return;
@@ -46,7 +47,16 @@ MutexAcquire(
 
     oldState = CpuIntrDisable();
 
-    LockAcquire(&Mutex->MutexLock, &dummyState );
+    //__halt();
+
+    LockAcquire(&Mutex->MutexLock, &dummyState);
+
+    // Priority donation if the current thread has a higher priority than the mutex holder
+    if (Mutex->Holder != NULL && pCurrentThread->Priority > Mutex->Holder->Priority)
+    {
+        Mutex->Holder->Priority = pCurrentThread->Priority;
+    }
+
     if (NULL == Mutex->Holder)
     {
         Mutex->Holder = pCurrentThread;
@@ -55,11 +65,12 @@ MutexAcquire(
 
     while (Mutex->Holder != pCurrentThread)
     {
-        InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
+        //InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
+        InsertOrderedList(&Mutex->WaitingList, &pCurrentThread->ReadyList, ThreadSchedulerCompareFunction, NULL);
         ThreadTakeBlockLock();
         LockRelease(&Mutex->MutexLock, dummyState);
         ThreadBlock();
-        LockAcquire(&Mutex->MutexLock, &dummyState );
+        LockAcquire(&Mutex->MutexLock, &dummyState);
     }
 
     _Analysis_assume_lock_acquired_(*Mutex);
@@ -67,20 +78,22 @@ MutexAcquire(
     LockRelease(&Mutex->MutexLock, dummyState);
 
     CpuIntrSetState(oldState);
+    LOG("MutexAcquire finished");
+    //__halt();
 }
-
 RELEASES_EXCL_AND_REENTRANT_LOCK(*Mutex)
 REQUIRES_EXCL_LOCK(*Mutex)
 void
 MutexRelease(
     INOUT       PMUTEX      Mutex
-    )
+)
 {
     INTR_STATE oldState;
     PLIST_ENTRY pEntry;
+    PTHREAD pCurrentThread = GetCurrentThread();
 
     ASSERT(NULL != Mutex);
-    ASSERT(GetCurrentThread() == Mutex->Holder);
+    ASSERT(pCurrentThread == Mutex->Holder);
 
     if (Mutex->CurrentRecursivityDepth > 1)
     {
@@ -97,13 +110,17 @@ MutexRelease(
     {
         PTHREAD pThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
 
-        // wakeup first thread
+        // Restore the original priority of the current thread before donation
+        pCurrentThread->Priority = pCurrentThread->OriginalPriority;
+
+        // Wake up the next thread waiting for the mutex
         Mutex->Holder = pThread;
         Mutex->CurrentRecursivityDepth = 1;
         ThreadUnblock(pThread);
     }
     else
     {
+        // No threads waiting, so release the mutex
         Mutex->Holder = NULL;
     }
 
diff --git a/HAL9000/src/sem.c b/HAL9000/src/sem.c
new file mode 100644
index 0000000..8cab8ab
--- /dev/null
+++ b/HAL9000/src/sem.c
@@ -0,0 +1,65 @@
+#include "sem.h"
+#include "thread.h"
+#include "thread_internal.h"
+#include "synch.h"
+
+_No_competing_thread_
+void
+SemaphoreInit(
+    OUT     PSEMAPHORE      Semaphore,
+    IN      DWORD           InitialValue
+)
+{
+    ASSERT(NULL != Semaphore);
+
+    memzero(Semaphore, sizeof(SEMAPHORE));
+
+    LockInit(&Semaphore->SemLock);
+
+    Semaphore->Value = InitialValue;
+    Semaphore->InitValue = InitialValue;
+
+    InitializeListHead(&Semaphore->WaitingList);
+    InitializeListHead(&Semaphore->RunningList);
+}
+
+void
+SemaphoreDown(
+    INOUT   PSEMAPHORE      Semaphore,
+    IN      DWORD           Value
+) 
+{
+    ASSERT(NULL != Semaphore);
+    ASSERT(Value > 0);
+
+    INTR_STATE oldState;
+    INTR_STATE cpuState;
+
+    cpuState = CpuIntrDisable();
+    PTHREAD pCurrentThread = GetCurrentThread();
+    ASSERT(NULL != pCurrentThread);
+
+    LockAcquire(&Semaphore->SemLock, &oldState);
+
+    // Verify if the current thread is not already in the running list
+    ASSERT(!IsListEntryInList(&Semaphore->RunningList, &pCurrentThread->SemaphoreList));
+
+    // Wait until there is sufficient value in the semaphore
+    while (Semaphore->Value < Value)
+    {
+        // Add to waiting list if there are not enough resources
+        InsertTailList(&Semaphore->WaitingList, &pCurrentThread->SemaphoreList);
+        ThreadTakeBlockLock();
+        LockRelease(&Semaphore->SemLock, oldState);
+        ThreadBlock();
+        LockAcquire(&Semaphore->SemLock, &oldState);
+    }
+
+    // Remove from waiting list and add to running list
+    RemoveEntryList(&pCurrentThread->SemaphoreList);
+    InsertTailList(&Semaphore->RunningList, &pCurrentThread->SemaphoreList);
+    Semaphore->Value -= Value;
+
+    LockRelease(&Semaphore->SemLock, oldState);
+    CpuIntrSetState(cpuState);
+}
diff --git a/HAL9000/src/sem.h b/HAL9000/src/sem.h
new file mode 100644
index 0000000..9fa37fc
--- /dev/null
+++ b/HAL9000/src/sem.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "HAL9000.h"
+#include "list.h"
+#include "synch.h"
+
+typedef struct _SEMAPHORE
+{
+	LOCK 		    SemLock;
+    
+    _Guarded_by_(SemLock)
+    DWORD           Value;
+
+	DWORD 	        InitValue;
+    
+    _Guarded_by_(SemLock)
+	LIST_ENTRY      WaitingList;
+
+    _Guarded_by_(SemLock)
+	LIST_ENTRY      RunningList;
+
+} SEMAPHORE, * PSEMAPHORE;
+
+void
+SemaphoreInit(
+    OUT     PSEMAPHORE      Semaphore,
+    IN      DWORD           InitialValue
+);
+
+void
+SemaphoreDown(
+    INOUT   PSEMAPHORE      Semaphore,
+    IN      DWORD           Value
+);
+
+void
+SemaphoreUp(
+    INOUT   PSEMAPHORE      Semaphore,
+    IN      DWORD           Value
+);
\ No newline at end of file
diff --git a/HAL9000/src/smp.c b/HAL9000/src/smp.c
index 7a35f1e..e26ea6a 100644
--- a/HAL9000/src/smp.c
+++ b/HAL9000/src/smp.c
@@ -379,6 +379,7 @@ SmpSendGenericIpi(
     IN      BOOLEAN                 WaitForHandling
     )
 {
+    LOG("SmpSendGenericIpi started");
     SMP_DESTINATION dest = { 0 };
 
     return SmpSendGenericIpiEx(BroadcastFunction,
@@ -386,9 +387,10 @@ SmpSendGenericIpi(
                                FreeFunction,
                                FreeContext,
                                WaitForHandling,
-                               SmpIpiSendToAllExcludingSelf,
+                               SmpIpiSendToAllIncludingSelf,
                                dest
                                );
+    //LOG("SmpSendGenericIpi finished");
 }
 
 STATUS
diff --git a/HAL9000/src/thread.c b/HAL9000/src/thread.c
index 3ec2095..9178af0 100644
--- a/HAL9000/src/thread.c
+++ b/HAL9000/src/thread.c
@@ -9,8 +9,9 @@
 #include "isr.h"
 #include "gdtmu.h"
 #include "pe_exports.h"
+#include "smp.h"
 
-#define TID_INCREMENT               4
+#define TID_INCREMENT               0x10
 
 #define THREAD_TIME_SLICE           1
 
@@ -36,6 +37,11 @@ typedef struct _THREAD_SYSTEM_DATA
 
     _Guarded_by_(ReadyThreadsLock)
     LIST_ENTRY          ReadyThreadsList;
+
+    QWORD               NumberOfThreads;
+
+    _Guarded_by_(ReadyThreadsLock)
+        THREAD_PRIORITY RunningThreadsMinPriority;
 } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
 
 static THREAD_SYSTEM_DATA m_threadSystemData;
@@ -138,6 +144,8 @@ ThreadSystemPreinit(
     void
     )
 {
+    //LOG("Thread ThreadSystemPreInit started");
+    //__halt();
     memzero(&m_threadSystemData, sizeof(THREAD_SYSTEM_DATA));
 
     InitializeListHead(&m_threadSystemData.AllThreadsList);
@@ -145,6 +153,13 @@ ThreadSystemPreinit(
 
     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
     LockInit(&m_threadSystemData.ReadyThreadsLock);
+
+    // m_threadSystemData.NumberOfThreads = 0;
+
+    m_threadSystemData.RunningThreadsMinPriority = ThreadPriorityReserved;
+
+    //LOG("Thread ThreadSystemPreInit finished");
+    //__halt();
 }
 
 STATUS
@@ -196,6 +211,31 @@ ThreadSystemInitMainForCurrentCPU(
     return status;
 }
 
+STATUS
+ThreadYieldForIpi(
+    IN_OPT PVOID Context
+)
+{
+    //LOG("ThreadYieldForIpi started");
+    //__halt();
+
+    UNREFERENCED_PARAMETER(Context);
+
+    INTR_STATE oldState = CpuIntrDisable();
+
+    PPCPU pCpu = GetCurrentPcpu();
+
+    ASSERT(NULL != pCpu);
+
+    pCpu->ThreadData.YieldOnInterruptReturn = TRUE;
+
+    CpuIntrSetState(oldState);
+
+    //LOG("ThreadYieldForIpi finished");
+    return STATUS_SUCCESS;
+}
+
+
 STATUS
 ThreadSystemInitIdleForCurrentCPU(
     void
@@ -269,6 +309,7 @@ ThreadCreate(
     OUT_PTR     PTHREAD*            Thread
     )
 {
+    LOG_TRACE_THREAD("ThreadCreate - Name: %s, Priority: %u\n", Name, Priority);
     return ThreadCreateEx(Name,
                           Priority,
                           Function,
@@ -447,24 +488,49 @@ ThreadTick(
     }
 }
 
+INT64 ThreadSchedulerCompareFunction(
+    IN PLIST_ENTRY FirstElem,
+    IN PLIST_ENTRY SecondElem,
+    IN_OPT PVOID Context
+) {
+    //LOG("First print from ThreadSchedulerCompareFunction");
+    //__halt();
+    UNREFERENCED_PARAMETER(Context);
+    PTHREAD pThread1 = CONTAINING_RECORD(FirstElem, THREAD, ReadyList);
+    PTHREAD pThread2 = CONTAINING_RECORD(SecondElem, THREAD, ReadyList);
+
+    if (pThread1->Priority < pThread2->Priority) {
+        return 1;
+    }
+    else if (pThread1->Priority > pThread2->Priority) {
+        return -1;
+    }
+    //LOG("Last print from ThreadSchedulerCompareFunction");
+    //__halt();
+    return 0;
+}
+
 void
 ThreadYield(
     void
-    )
+)
 {
+    //LOG("ThreadYield started");
     INTR_STATE dummyState;
     INTR_STATE oldState;
     PTHREAD pThread = GetCurrentThread();
     PPCPU pCpu;
     BOOLEAN bForcedYield;
 
-    ASSERT( NULL != pThread);
+    //__halt();
+
+    ASSERT(NULL != pThread);
 
     oldState = CpuIntrDisable();
 
     pCpu = GetCurrentPcpu();
 
-    ASSERT( NULL != pCpu );
+    ASSERT(NULL != pCpu);
 
     bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
     pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
@@ -478,18 +544,22 @@ ThreadYield(
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
     if (pThread != pCpu->ThreadData.IdleThread)
     {
-        InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
+        //InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
+        InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList, ThreadSchedulerCompareFunction, NULL);
     }
     if (!bForcedYield)
     {
         pThread->TickCountEarly++;
     }
+    
     pThread->State = ThreadStateReady;
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(!LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
     LOG_TRACE_THREAD("Returned from _ThreadSchedule\n");
 
     CpuIntrSetState(oldState);
+    //LOG("ThreadYield finished");
+    //__halt();
 }
 
 void
@@ -525,6 +595,9 @@ ThreadUnblock(
 {
     INTR_STATE oldState;
     INTR_STATE dummyState;
+    //__halt();
+    //aici nu pusca
+    //__halt();
 
     ASSERT(NULL != Thread);
 
@@ -533,7 +606,25 @@ ThreadUnblock(
     ASSERT(ThreadStateBlocked == Thread->State);
 
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
-    InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
+    
+    InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList, ThreadSchedulerCompareFunction, NULL);
+    SmpSendGenericIpi(ThreadYieldForIpi, NULL, NULL, NULL, FALSE);
+    
+    //InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
+
+    //THREAD_PRIORITY newPrio = ThreadGetPriority(Thread);
+
+    //aici pusca deja
+    //__halt();
+
+    /*if (newPrio > m_threadSystemData.RunningThreadsMinPriority)
+    {
+        SmpSendGenericIpi(ThreadYieldForIpi, NULL, NULL, NULL, FALSE);
+    }
+    else 
+    {
+        InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList, ThreadSchedulerCompareFunction, NULL);
+    }*/
     Thread->State = ThreadStateReady;
     LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
     LockRelease(&Thread->BlockLock, oldState);
@@ -551,6 +642,8 @@ ThreadExit(
 
     pThread = GetCurrentThread();
 
+    //LOG("Thread finished name: %s TID %x", pThread->Name, pThread->Id);
+
     CpuIntrDisable();
 
     if (LockIsOwner(&pThread->BlockLock))
@@ -566,6 +659,7 @@ ThreadExit(
 
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
     _ThreadSchedule();
+    //m_threadSystemData.NumberOfThreads -= 1;
     NOT_REACHED;
 }
 
@@ -653,14 +747,31 @@ ThreadGetPriority(
     return (NULL != pThread) ? pThread->Priority : 0;
 }
 
+//annotation
 void
 ThreadSetPriority(
     IN      THREAD_PRIORITY     NewPriority
     )
 {
+    //LOG("ThreadSetPriority started");
+    INTR_STATE oldState;
+    INTR_STATE dummyState;
+    oldState = CpuIntrDisable();
     ASSERT(ThreadPriorityLowest <= NewPriority && NewPriority <= ThreadPriorityMaximum);
 
     GetCurrentThread()->Priority = NewPriority;
+
+    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
+
+    if (NewPriority < m_threadSystemData.RunningThreadsMinPriority) {
+        ThreadYield();
+    }
+
+    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState);
+
+    CpuIntrSetState(oldState);
+
+    //LOG("ThreadSetPriority finished");
 }
 
 STATUS
@@ -793,12 +904,19 @@ _ThreadInit(
         pThread->Id = _ThreadSystemGetNextTid();
         pThread->State = ThreadStateBlocked;
         pThread->Priority = Priority;
+        
+        //ASSERT(0 != (*Thread)->parentTid);
+        //pThread->parentTid = (*Thread)->parentTid;
+        //LOG("Parent TID %x", pThread->parentTid);
 
         LockInit(&pThread->BlockLock);
 
         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
+
+        //LOG("Created thread: name %s TID = %x\n", pThread->Name, pThread->Id);
+        //m_threadSystemData.NumberOfThreads++;
     }
     __finally
     {
@@ -1105,14 +1223,14 @@ _Ret_notnull_
 PTHREAD
 _ThreadGetReadyThread(
     void
-    )
+)
 {
     PTHREAD pNextThread;
     PLIST_ENTRY pEntry;
     BOOLEAN bIdleScheduled;
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
-    ASSERT( LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 
     pNextThread = NULL;
 
@@ -1124,9 +1242,9 @@ _ThreadGetReadyThread(
     }
     else
     {
-        pNextThread = CONTAINING_RECORD( pEntry, THREAD, ReadyList );
+        pNextThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
 
-        ASSERT( pNextThread->State == ThreadStateReady );
+        ASSERT(pNextThread->State == ThreadStateReady);
         bIdleScheduled = FALSE;
     }
 
diff --git a/lab4.txt b/lab4.txt
new file mode 100644
index 0000000..aa2c758
--- /dev/null
+++ b/lab4.txt
@@ -0,0 +1,746 @@
+diff --git a/.vs/HAL9000/v16/.suo b/.vs/HAL9000/v16/.suo
+index 1e8654c..e88e657 100644
+Binary files a/.vs/HAL9000/v16/.suo and b/.vs/HAL9000/v16/.suo differ
+diff --git a/.vs/HAL9000/v16/Browse.VC.db b/.vs/HAL9000/v16/Browse.VC.db
+index 2927340..8f87e4e 100644
+Binary files a/.vs/HAL9000/v16/Browse.VC.db and b/.vs/HAL9000/v16/Browse.VC.db differ
+diff --git a/.vs/HAL9000/v16/Solution.VC.db b/.vs/HAL9000/v16/Solution.VC.db
+index ea5c763..507156b 100644
+Binary files a/.vs/HAL9000/v16/Solution.VC.db and b/.vs/HAL9000/v16/Solution.VC.db differ
+diff --git a/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch b/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch
+index 1ab2535..e8f1534 100644
+Binary files a/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch and b/.vs/HAL9000/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch differ
+diff --git a/.vs/HAL9000/v16/ipch/AutoPCH/3504819d756ddbe9/THREAD.ipch b/.vs/HAL9000/v16/ipch/AutoPCH/3504819d756ddbe9/THREAD.ipch
+new file mode 100644
+index 0000000..57f99fc
+Binary files /dev/null and b/.vs/HAL9000/v16/ipch/AutoPCH/3504819d756ddbe9/THREAD.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/.suo b/.vs/HAL9000_WithoutApplications/v16/.suo
+index fab7dce..1adc540 100644
+Binary files a/.vs/HAL9000_WithoutApplications/v16/.suo and b/.vs/HAL9000_WithoutApplications/v16/.suo differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db b/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db
+index b19850c..3159025 100644
+Binary files a/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db and b/.vs/HAL9000_WithoutApplications/v16/Browse.VC.db differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db b/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db
+index 9bd9e64..ddc43ee 100644
+Binary files a/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db and b/.vs/HAL9000_WithoutApplications/v16/Solution.VC.db differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/1ef05c8314040276/MUTEX.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/1ef05c8314040276/MUTEX.ipch
+new file mode 100644
+index 0000000..fda57e6
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/1ef05c8314040276/MUTEX.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2357e4494828d1be/SPINLOCK.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2357e4494828d1be/SPINLOCK.ipch
+new file mode 100644
+index 0000000..7f485fb
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2357e4494828d1be/SPINLOCK.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2371012fc45db0e5/THREAD.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2371012fc45db0e5/THREAD.ipch
+new file mode 100644
+index 0000000..6754aad
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2371012fc45db0e5/THREAD.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch
+index bed45ed..ab902d9 100644
+Binary files a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2702ab20af2261fd/THREAD.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2a818a5d2cfd32ae/ACPI_INTERFACE.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2a818a5d2cfd32ae/ACPI_INTERFACE.ipch
+new file mode 100644
+index 0000000..a68a59e
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/2a818a5d2cfd32ae/ACPI_INTERFACE.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/4a2cad7545002cd8/IDT_HANDLERS.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/4a2cad7545002cd8/IDT_HANDLERS.ipch
+new file mode 100644
+index 0000000..ba415ea
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/4a2cad7545002cd8/IDT_HANDLERS.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/5177c890ace0e7cd/SMP.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/5177c890ace0e7cd/SMP.ipch
+new file mode 100644
+index 0000000..fa3b953
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/5177c890ace0e7cd/SMP.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/64b347674aaff517/LOG.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/64b347674aaff517/LOG.ipch
+new file mode 100644
+index 0000000..2a40c4f
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/64b347674aaff517/LOG.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/6b47ada2dc567d6b/ISR.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/6b47ada2dc567d6b/ISR.ipch
+new file mode 100644
+index 0000000..40e1732
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/6b47ada2dc567d6b/ISR.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/705c3ff52df7407f/ENTRY64.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/705c3ff52df7407f/ENTRY64.ipch
+new file mode 100644
+index 0000000..3f8a6ed
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/705c3ff52df7407f/ENTRY64.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/7ee9b6bb5176d52c/TEST_THREAD.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/7ee9b6bb5176d52c/TEST_THREAD.ipch
+new file mode 100644
+index 0000000..2f84474
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/7ee9b6bb5176d52c/TEST_THREAD.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/a186d121de9bcbbb/ASSERT.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/a186d121de9bcbbb/ASSERT.ipch
+new file mode 100644
+index 0000000..c7e5d47
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/a186d121de9bcbbb/ASSERT.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ac0dbac2f758ccf6/ACPI_INTERFACE.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ac0dbac2f758ccf6/ACPI_INTERFACE.ipch
+new file mode 100644
+index 0000000..d390c39
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ac0dbac2f758ccf6/ACPI_INTERFACE.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/b604a6d970aa58b/TEST_TIMER.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/b604a6d970aa58b/TEST_TIMER.ipch
+new file mode 100644
+index 0000000..828f86f
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/b604a6d970aa58b/TEST_TIMER.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ce1d13151b21ceb0/LOCK_COMMON.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ce1d13151b21ceb0/LOCK_COMMON.ipch
+new file mode 100644
+index 0000000..a69ade0
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/ce1d13151b21ceb0/LOCK_COMMON.ipch differ
+diff --git a/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/f7d7cc9ccc14f827/EX_EVENT.ipch b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/f7d7cc9ccc14f827/EX_EVENT.ipch
+new file mode 100644
+index 0000000..d148732
+Binary files /dev/null and b/.vs/HAL9000_WithoutApplications/v16/ipch/AutoPCH/f7d7cc9ccc14f827/EX_EVENT.ipch differ
+diff --git a/HAL9000/headers/thread_internal.h b/HAL9000/headers/thread_internal.h
+index 789fe68..a80e747 100644
+--- a/HAL9000/headers/thread_internal.h
++++ b/HAL9000/headers/thread_internal.h
+@@ -40,6 +40,10 @@ typedef struct _THREAD
+     TID                     Id;
+     char*                   Name;
+ 
++    //bagat de la mine
++    QWORD lastScheduledTime;
++    THREAD_PRIORITY OriginalPriority;
++
+     // Currently the thread priority is not used for anything
+     THREAD_PRIORITY         Priority;
+     THREAD_STATE            State;
+@@ -90,6 +94,8 @@ typedef struct _THREAD
+     PVOID                   UserStack;
+ 
+     struct _PROCESS*        Process;
++
++    TID parentTid;
+ } THREAD, *PTHREAD;
+ 
+ //******************************************************************************
+diff --git a/HAL9000/src/ex_event.c b/HAL9000/src/ex_event.c
+index 8c58e20..a73450a 100644
+--- a/HAL9000/src/ex_event.c
++++ b/HAL9000/src/ex_event.c
+@@ -1,6 +1,7 @@
+ #include "HAL9000.h"
+ #include "ex_event.h"
+ #include "thread_internal.h"
++#include "thread.h"
+ 
+ #include "cpumu.h"
+ 
+@@ -80,6 +81,8 @@ ExEventWaitForSignal(
+     INOUT   EX_EVENT*      Event
+     )
+ {
++    LOG("ExEventWaitForSignal started");
++    //__halt();
+     PTHREAD pCurrentThread;
+     INTR_STATE dummyState;
+     INTR_STATE oldState;
+@@ -97,7 +100,8 @@ ExEventWaitForSignal(
+     while (TRUE != _InterlockedCompareExchange8(&Event->Signaled, newState, TRUE))
+     {
+         LockAcquire(&Event->EventLock, &dummyState);
+-        InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
++        //InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
++        InsertOrderedList(&Event->WaitingList, &pCurrentThread->ReadyList, ThreadSchedulerCompareFunction, NULL);
+         ThreadTakeBlockLock();
+         LockRelease(&Event->EventLock, dummyState);
+         ThreadBlock();
+@@ -110,6 +114,8 @@ ExEventWaitForSignal(
+             break;
+         }
+     }
+-
++    LOG("ExEventWaitForSignal finished");
++    //__halt();
+     CpuIntrSetState(oldState);
++    //LOG("ExEventWaitForSignal finished");
+ }
+\ No newline at end of file
+diff --git a/HAL9000/src/mutex.c b/HAL9000/src/mutex.c
+index 9c82227..3a129fe 100644
+--- a/HAL9000/src/mutex.c
++++ b/HAL9000/src/mutex.c
+@@ -21,24 +21,25 @@ MutexInit(
+ 
+     Mutex->MaxRecursivityDepth = Recursive ? MUTEX_MAX_RECURSIVITY_DEPTH : 1;
+ }
+-
+ ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Mutex)
+ REQUIRES_NOT_HELD_LOCK(*Mutex)
+ void
+ MutexAcquire(
+     INOUT       PMUTEX      Mutex
+-    )
++)
+ {
++    LOG("MutexAcquire started");
++    //__halt();
+     INTR_STATE dummyState;
+     INTR_STATE oldState;
+     PTHREAD pCurrentThread = GetCurrentThread();
+ 
+-    ASSERT( NULL != Mutex);
+-    ASSERT( NULL != pCurrentThread );
++    ASSERT(NULL != Mutex);
++    ASSERT(NULL != pCurrentThread);
+ 
+     if (pCurrentThread == Mutex->Holder)
+     {
+-        ASSERT( Mutex->CurrentRecursivityDepth < Mutex->MaxRecursivityDepth );
++        ASSERT(Mutex->CurrentRecursivityDepth < Mutex->MaxRecursivityDepth);
+ 
+         Mutex->CurrentRecursivityDepth++;
+         return;
+@@ -46,7 +47,16 @@ MutexAcquire(
+ 
+     oldState = CpuIntrDisable();
+ 
+-    LockAcquire(&Mutex->MutexLock, &dummyState );
++    //__halt();
++
++    LockAcquire(&Mutex->MutexLock, &dummyState);
++
++    // Priority donation if the current thread has a higher priority than the mutex holder
++    if (Mutex->Holder != NULL && pCurrentThread->Priority > Mutex->Holder->Priority)
++    {
++        Mutex->Holder->Priority = pCurrentThread->Priority;
++    }
++
+     if (NULL == Mutex->Holder)
+     {
+         Mutex->Holder = pCurrentThread;
+@@ -55,11 +65,12 @@ MutexAcquire(
+ 
+     while (Mutex->Holder != pCurrentThread)
+     {
+-        InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
++        //InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
++        InsertOrderedList(&Mutex->WaitingList, &pCurrentThread->ReadyList, ThreadSchedulerCompareFunction, NULL);
+         ThreadTakeBlockLock();
+         LockRelease(&Mutex->MutexLock, dummyState);
+         ThreadBlock();
+-        LockAcquire(&Mutex->MutexLock, &dummyState );
++        LockAcquire(&Mutex->MutexLock, &dummyState);
+     }
+ 
+     _Analysis_assume_lock_acquired_(*Mutex);
+@@ -67,20 +78,22 @@ MutexAcquire(
+     LockRelease(&Mutex->MutexLock, dummyState);
+ 
+     CpuIntrSetState(oldState);
++    LOG("MutexAcquire finished");
++    //__halt();
+ }
+-
+ RELEASES_EXCL_AND_REENTRANT_LOCK(*Mutex)
+ REQUIRES_EXCL_LOCK(*Mutex)
+ void
+ MutexRelease(
+     INOUT       PMUTEX      Mutex
+-    )
++)
+ {
+     INTR_STATE oldState;
+     PLIST_ENTRY pEntry;
++    PTHREAD pCurrentThread = GetCurrentThread();
+ 
+     ASSERT(NULL != Mutex);
+-    ASSERT(GetCurrentThread() == Mutex->Holder);
++    ASSERT(pCurrentThread == Mutex->Holder);
+ 
+     if (Mutex->CurrentRecursivityDepth > 1)
+     {
+@@ -97,13 +110,17 @@ MutexRelease(
+     {
+         PTHREAD pThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
+ 
+-        // wakeup first thread
++        // Restore the original priority of the current thread before donation
++        pCurrentThread->Priority = pCurrentThread->OriginalPriority;
++
++        // Wake up the next thread waiting for the mutex
+         Mutex->Holder = pThread;
+         Mutex->CurrentRecursivityDepth = 1;
+         ThreadUnblock(pThread);
+     }
+     else
+     {
++        // No threads waiting, so release the mutex
+         Mutex->Holder = NULL;
+     }
+ 
+diff --git a/HAL9000/src/sem.c b/HAL9000/src/sem.c
+new file mode 100644
+index 0000000..c6f4886
+--- /dev/null
++++ b/HAL9000/src/sem.c
+@@ -0,0 +1,84 @@
++#include "sem.h"
++#include "thread.h"
++#include "thread_internal.h"
++#include "synch.h"
++
++_No_competing_thread_
++void
++SemaphoreInit(
++    OUT     PSEMAPHORE      Semaphore,
++    IN      DWORD           InitialValue
++)
++{
++
++	ASSERT(NULL != Semaphore);
++
++	memzero(Semaphore, sizeof(SEMAPHORE));
++
++	LockInit(&Semaphore->SemLock);
++
++	Semaphore->Value = InitialValue;
++
++	InitializeListHead(&Semaphore->WaitingList);
++	InitializeListHead(&Semaphore->RunningList);
++
++	Semaphore->InitValue = InitialValue;
++}
++
++
++void
++SemaphoreDown(
++	INOUT   PSEMAPHORE      Semaphore,
++	IN      DWORD           Value
++) 
++{
++	UNREFERENCED_PARAMETER(Value);
++	UNREFERENCED_PARAMETER(Semaphore);
++
++	PTHREAD pCurrentThread = GetCurrentThread();
++
++	ASSERT(NULL != Semaphore);
++	ASSERT(NULL != pCurrentThread);
++
++	INTR_STATE oldState;
++	INTR_STATE CpuState;
++
++	CpuState = CpuIntrDisable();
++
++	LockAcquire(&Semaphore->SemLock, &oldState);
++	
++	//verify if the current thread is already in the running list
++	//ASSERT(pCurrentThread->SemaphoreList is NOT in Sem->RunningList)
++
++	while (Semaphore->Value  >= Value)
++	{
++		InsertTailList(&Semaphore->WaitingList, &pCurrentThread->SemaphoreList);
++		ThreadTakeBlockLock();
++		LockRelease(&Semaphore->SemLock, oldState);
++		ThreadBlock();
++		//after thread is unblocked
++		LockAcquire(&Semaphore->SemLock, &oldState);
++	}
++
++	RemoveEntryList(&pCurrentThread->SemaphoreList);
++	InsertTailList(&Semaphore->RunningList, &pCurrentThread->SemaphoreList);
++	Semaphore->Value-=Value;
++
++
++	LockRelease(&Semaphore->SemLock, oldState);
++	CpuIntrSetState(CpuState);
++
++}
++void
++SemaphoreUp(
++    INOUT   PSEMAPHORE      Semaphore,
++    IN      DWORD           Value
++)
++{
++	UNREFERENCED_PARAMETER(Value);
++	UNREFERENCED_PARAMETER(Semaphore);
++
++	//verify if the current thread is already in the running 
++	//ASSERT(pCurrentThread->SemaphoreList is NOT in Sem)
++	// if sem->value + Value > sem->InitValue then sem->value = sem->InitValue
++}
+\ No newline at end of file
+diff --git a/HAL9000/src/sem.h b/HAL9000/src/sem.h
+new file mode 100644
+index 0000000..9fa37fc
+--- /dev/null
++++ b/HAL9000/src/sem.h
+@@ -0,0 +1,39 @@
++#pragma once
++#include "HAL9000.h"
++#include "list.h"
++#include "synch.h"
++
++typedef struct _SEMAPHORE
++{
++	LOCK 		    SemLock;
++    
++    _Guarded_by_(SemLock)
++    DWORD           Value;
++
++	DWORD 	        InitValue;
++    
++    _Guarded_by_(SemLock)
++	LIST_ENTRY      WaitingList;
++
++    _Guarded_by_(SemLock)
++	LIST_ENTRY      RunningList;
++
++} SEMAPHORE, * PSEMAPHORE;
++
++void
++SemaphoreInit(
++    OUT     PSEMAPHORE      Semaphore,
++    IN      DWORD           InitialValue
++);
++
++void
++SemaphoreDown(
++    INOUT   PSEMAPHORE      Semaphore,
++    IN      DWORD           Value
++);
++
++void
++SemaphoreUp(
++    INOUT   PSEMAPHORE      Semaphore,
++    IN      DWORD           Value
++);
+\ No newline at end of file
+diff --git a/HAL9000/src/smp.c b/HAL9000/src/smp.c
+index 7a35f1e..e26ea6a 100644
+--- a/HAL9000/src/smp.c
++++ b/HAL9000/src/smp.c
+@@ -379,6 +379,7 @@ SmpSendGenericIpi(
+     IN      BOOLEAN                 WaitForHandling
+     )
+ {
++    LOG("SmpSendGenericIpi started");
+     SMP_DESTINATION dest = { 0 };
+ 
+     return SmpSendGenericIpiEx(BroadcastFunction,
+@@ -386,9 +387,10 @@ SmpSendGenericIpi(
+                                FreeFunction,
+                                FreeContext,
+                                WaitForHandling,
+-                               SmpIpiSendToAllExcludingSelf,
++                               SmpIpiSendToAllIncludingSelf,
+                                dest
+                                );
++    //LOG("SmpSendGenericIpi finished");
+ }
+ 
+ STATUS
+diff --git a/HAL9000/src/thread.c b/HAL9000/src/thread.c
+index 3ec2095..9178af0 100644
+--- a/HAL9000/src/thread.c
++++ b/HAL9000/src/thread.c
+@@ -9,8 +9,9 @@
+ #include "isr.h"
+ #include "gdtmu.h"
+ #include "pe_exports.h"
++#include "smp.h"
+ 
+-#define TID_INCREMENT               4
++#define TID_INCREMENT               0x10
+ 
+ #define THREAD_TIME_SLICE           1
+ 
+@@ -36,6 +37,11 @@ typedef struct _THREAD_SYSTEM_DATA
+ 
+     _Guarded_by_(ReadyThreadsLock)
+     LIST_ENTRY          ReadyThreadsList;
++
++    QWORD               NumberOfThreads;
++
++    _Guarded_by_(ReadyThreadsLock)
++        THREAD_PRIORITY RunningThreadsMinPriority;
+ } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
+ 
+ static THREAD_SYSTEM_DATA m_threadSystemData;
+@@ -138,6 +144,8 @@ ThreadSystemPreinit(
+     void
+     )
+ {
++    //LOG("Thread ThreadSystemPreInit started");
++    //__halt();
+     memzero(&m_threadSystemData, sizeof(THREAD_SYSTEM_DATA));
+ 
+     InitializeListHead(&m_threadSystemData.AllThreadsList);
+@@ -145,6 +153,13 @@ ThreadSystemPreinit(
+ 
+     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
+     LockInit(&m_threadSystemData.ReadyThreadsLock);
++
++    // m_threadSystemData.NumberOfThreads = 0;
++
++    m_threadSystemData.RunningThreadsMinPriority = ThreadPriorityReserved;
++
++    //LOG("Thread ThreadSystemPreInit finished");
++    //__halt();
+ }
+ 
+ STATUS
+@@ -196,6 +211,31 @@ ThreadSystemInitMainForCurrentCPU(
+     return status;
+ }
+ 
++STATUS
++ThreadYieldForIpi(
++    IN_OPT PVOID Context
++)
++{
++    //LOG("ThreadYieldForIpi started");
++    //__halt();
++
++    UNREFERENCED_PARAMETER(Context);
++
++    INTR_STATE oldState = CpuIntrDisable();
++
++    PPCPU pCpu = GetCurrentPcpu();
++
++    ASSERT(NULL != pCpu);
++
++    pCpu->ThreadData.YieldOnInterruptReturn = TRUE;
++
++    CpuIntrSetState(oldState);
++
++    //LOG("ThreadYieldForIpi finished");
++    return STATUS_SUCCESS;
++}
++
++
+ STATUS
+ ThreadSystemInitIdleForCurrentCPU(
+     void
+@@ -269,6 +309,7 @@ ThreadCreate(
+     OUT_PTR     PTHREAD*            Thread
+     )
+ {
++    LOG_TRACE_THREAD("ThreadCreate - Name: %s, Priority: %u\n", Name, Priority);
+     return ThreadCreateEx(Name,
+                           Priority,
+                           Function,
+@@ -447,24 +488,49 @@ ThreadTick(
+     }
+ }
+ 
++INT64 ThreadSchedulerCompareFunction(
++    IN PLIST_ENTRY FirstElem,
++    IN PLIST_ENTRY SecondElem,
++    IN_OPT PVOID Context
++) {
++    //LOG("First print from ThreadSchedulerCompareFunction");
++    //__halt();
++    UNREFERENCED_PARAMETER(Context);
++    PTHREAD pThread1 = CONTAINING_RECORD(FirstElem, THREAD, ReadyList);
++    PTHREAD pThread2 = CONTAINING_RECORD(SecondElem, THREAD, ReadyList);
++
++    if (pThread1->Priority < pThread2->Priority) {
++        return 1;
++    }
++    else if (pThread1->Priority > pThread2->Priority) {
++        return -1;
++    }
++    //LOG("Last print from ThreadSchedulerCompareFunction");
++    //__halt();
++    return 0;
++}
++
+ void
+ ThreadYield(
+     void
+-    )
++)
+ {
++    //LOG("ThreadYield started");
+     INTR_STATE dummyState;
+     INTR_STATE oldState;
+     PTHREAD pThread = GetCurrentThread();
+     PPCPU pCpu;
+     BOOLEAN bForcedYield;
+ 
+-    ASSERT( NULL != pThread);
++    //__halt();
++
++    ASSERT(NULL != pThread);
+ 
+     oldState = CpuIntrDisable();
+ 
+     pCpu = GetCurrentPcpu();
+ 
+-    ASSERT( NULL != pCpu );
++    ASSERT(NULL != pCpu);
+ 
+     bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
+     pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
+@@ -478,18 +544,22 @@ ThreadYield(
+     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
+     if (pThread != pCpu->ThreadData.IdleThread)
+     {
+-        InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
++        //InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
++        InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList, ThreadSchedulerCompareFunction, NULL);
+     }
+     if (!bForcedYield)
+     {
+         pThread->TickCountEarly++;
+     }
++    
+     pThread->State = ThreadStateReady;
+     _ThreadSchedule();
+-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
++    ASSERT(!LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+     LOG_TRACE_THREAD("Returned from _ThreadSchedule\n");
+ 
+     CpuIntrSetState(oldState);
++    //LOG("ThreadYield finished");
++    //__halt();
+ }
+ 
+ void
+@@ -525,6 +595,9 @@ ThreadUnblock(
+ {
+     INTR_STATE oldState;
+     INTR_STATE dummyState;
++    //__halt();
++    //aici nu pusca
++    //__halt();
+ 
+     ASSERT(NULL != Thread);
+ 
+@@ -533,7 +606,25 @@ ThreadUnblock(
+     ASSERT(ThreadStateBlocked == Thread->State);
+ 
+     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
+-    InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
++    
++    InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList, ThreadSchedulerCompareFunction, NULL);
++    SmpSendGenericIpi(ThreadYieldForIpi, NULL, NULL, NULL, FALSE);
++    
++    //InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
++
++    //THREAD_PRIORITY newPrio = ThreadGetPriority(Thread);
++
++    //aici pusca deja
++    //__halt();
++
++    /*if (newPrio > m_threadSystemData.RunningThreadsMinPriority)
++    {
++        SmpSendGenericIpi(ThreadYieldForIpi, NULL, NULL, NULL, FALSE);
++    }
++    else 
++    {
++        InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList, ThreadSchedulerCompareFunction, NULL);
++    }*/
+     Thread->State = ThreadStateReady;
+     LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
+     LockRelease(&Thread->BlockLock, oldState);
+@@ -551,6 +642,8 @@ ThreadExit(
+ 
+     pThread = GetCurrentThread();
+ 
++    //LOG("Thread finished name: %s TID %x", pThread->Name, pThread->Id);
++
+     CpuIntrDisable();
+ 
+     if (LockIsOwner(&pThread->BlockLock))
+@@ -566,6 +659,7 @@ ThreadExit(
+ 
+     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
+     _ThreadSchedule();
++    //m_threadSystemData.NumberOfThreads -= 1;
+     NOT_REACHED;
+ }
+ 
+@@ -653,14 +747,31 @@ ThreadGetPriority(
+     return (NULL != pThread) ? pThread->Priority : 0;
+ }
+ 
++//annotation
+ void
+ ThreadSetPriority(
+     IN      THREAD_PRIORITY     NewPriority
+     )
+ {
++    //LOG("ThreadSetPriority started");
++    INTR_STATE oldState;
++    INTR_STATE dummyState;
++    oldState = CpuIntrDisable();
+     ASSERT(ThreadPriorityLowest <= NewPriority && NewPriority <= ThreadPriorityMaximum);
+ 
+     GetCurrentThread()->Priority = NewPriority;
++
++    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
++
++    if (NewPriority < m_threadSystemData.RunningThreadsMinPriority) {
++        ThreadYield();
++    }
++
++    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState);
++
++    CpuIntrSetState(oldState);
++
++    //LOG("ThreadSetPriority finished");
+ }
+ 
+ STATUS
+@@ -793,12 +904,19 @@ _ThreadInit(
+         pThread->Id = _ThreadSystemGetNextTid();
+         pThread->State = ThreadStateBlocked;
+         pThread->Priority = Priority;
++        
++        //ASSERT(0 != (*Thread)->parentTid);
++        //pThread->parentTid = (*Thread)->parentTid;
++        //LOG("Parent TID %x", pThread->parentTid);
+ 
+         LockInit(&pThread->BlockLock);
+ 
+         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
+         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
+         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
++
++        //LOG("Created thread: name %s TID = %x\n", pThread->Name, pThread->Id);
++        //m_threadSystemData.NumberOfThreads++;
+     }
+     __finally
+     {
+@@ -1105,14 +1223,14 @@ _Ret_notnull_
+ PTHREAD
+ _ThreadGetReadyThread(
+     void
+-    )
++)
+ {
+     PTHREAD pNextThread;
+     PLIST_ENTRY pEntry;
+     BOOLEAN bIdleScheduled;
+ 
+-    ASSERT( INTR_OFF == CpuIntrGetState());
+-    ASSERT( LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
++    ASSERT(INTR_OFF == CpuIntrGetState());
++    ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+ 
+     pNextThread = NULL;
+ 
+@@ -1124,9 +1242,9 @@ _ThreadGetReadyThread(
+     }
+     else
+     {
+-        pNextThread = CONTAINING_RECORD( pEntry, THREAD, ReadyList );
++        pNextThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
+ 
+-        ASSERT( pNextThread->State == ThreadStateReady );
++        ASSERT(pNextThread->State == ThreadStateReady);
+         bIdleScheduled = FALSE;
+     }
+ 
+diff --git a/shared/kernel/thread.h b/shared/kernel/thread.h
+index 05efb4a..9966321 100644
+--- a/shared/kernel/thread.h
++++ b/shared/kernel/thread.h
+@@ -119,3 +119,9 @@ THREAD_PRIORITY
+ ThreadGetPriority(
+     IN_OPT  PTHREAD             Thread
+     );
++
++INT64 __cdecl ThreadSchedulerCompareFunction(
++    IN PLIST_ENTRY FirstElem,
++    IN PLIST_ENTRY SecondElem,
++    IN_OPT PVOID Context
++);
diff --git a/shared/kernel/thread.h b/shared/kernel/thread.h
index 05efb4a..9966321 100644
--- a/shared/kernel/thread.h
+++ b/shared/kernel/thread.h
@@ -119,3 +119,9 @@ THREAD_PRIORITY
 ThreadGetPriority(
     IN_OPT  PTHREAD             Thread
     );
+
+INT64 __cdecl ThreadSchedulerCompareFunction(
+    IN PLIST_ENTRY FirstElem,
+    IN PLIST_ENTRY SecondElem,
+    IN_OPT PVOID Context
+);
